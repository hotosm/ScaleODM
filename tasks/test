# List available commands
[private]
default:
  just --justfile {{justfile()}} --list test

# Check if Kubernetes cluster is available and configured
[private]
_check-cluster:
  #!/usr/bin/env bash
  set +e
  
  # Check if kubectl is available
  if ! command -v kubectl &> /dev/null; then
      exit 1
  fi
  
  # Check if we can connect to the cluster
  if ! kubectl cluster-info &> /dev/null; then
      exit 1
  fi
  
  # Check if we can get nodes (basic connectivity test)
  if ! kubectl get nodes &> /dev/null; then
      exit 1
  fi
  
  exit 0

# Check test k8s cluster available
cluster-available:
  #!/usr/bin/env bash
  set -e

  echo "Checking for Kubernetes cluster..."
  # Use the test module's private _check-cluster recipe explicitly
  if ! just test _check-cluster; then
      echo "‚ö†Ô∏è  Kubernetes cluster not available"
      echo "üì¶ Initializing test cluster (this may take a few minutes)..."
      # Non-interactive mode will be auto-detected (no TTY in CI)
      just test cluster-init
  else
      echo "‚úì Kubernetes cluster is available"
  fi
  echo ""

# Setup Talos Kubernetes cluster for testing (idempotent)
cluster-init:
  #!/usr/bin/env bash
  set -e
  
  CLUSTER_NAME="${TALOS_CLUSTER_NAME:-scaleodm-test}"
  WORKER_MEMORY="${TALOS_WORKER_MEMORY:-5142}"
  CONTROL_PLANE_MEMORY="${TALOS_CONTROL_PLANE_MEMORY:-2048}"
  NAMESPACE="${K8S_NAMESPACE:-argo}"
  ARGO_VERSION="${ARGO_WORKFLOWS_VERSION:-v3.7.3}"
  
  echo "üöÄ Setting up Talos cluster for ScaleODM testing..."
  echo "   Cluster name: $CLUSTER_NAME"
  echo "   Worker memory: ${WORKER_MEMORY}MB"
  echo "   Control plane memory: ${CONTROL_PLANE_MEMORY}MB"
  echo ""
  
  # Ensure br_netfilter kernel module is loaded (required for Flannel networking in Docker)
  if ! lsmod | grep -q "^br_netfilter"; then
      echo "üì¶ Loading br_netfilter kernel module..."
      if sudo modprobe br_netfilter 2>/dev/null; then
          echo "‚úì br_netfilter module loaded"
      else
          echo "‚ö†Ô∏è  Warning: Failed to load br_netfilter module"
          echo "   This may cause issues with Kubernetes networking in Docker"
          echo "   If cluster creation fails, ensure the module can be loaded"
      fi
  else
      echo "‚úì br_netfilter module already loaded"
  fi
  
  # Install required tools if missing
  just _install-curl
  just _install-talosctl
  just _install-kubectl
  
  # Check if the expected cluster exists and is accessible
  # Scope `talosctl cluster show` to the expected cluster name so we
  # can correctly detect when that cluster already exists.
  CLUSTER_SHOW_OUTPUT=$(talosctl cluster show --name "$CLUSTER_NAME" 2>/dev/null || echo "")
  if [ -n "$CLUSTER_SHOW_OUTPUT" ]; then
      CURRENT_CLUSTER=$(echo "$CLUSTER_SHOW_OUTPUT" | grep "^NAME" | awk '{print $2}' | head -1 | tr -d '\n\r' || echo "")
      NODE_COUNT=$(echo "$CLUSTER_SHOW_OUTPUT" | grep -E "^[a-z].*-.*(controlplane|worker)" | wc -l | tr -d '[:space:]')
      
      if [ -z "$NODE_COUNT" ] || ! [ "$NODE_COUNT" -ge 0 ] 2>/dev/null; then
          NODE_COUNT=0
      fi
      
      # Check if a different cluster is running
      if [ -n "$CURRENT_CLUSTER" ] && [ "$NODE_COUNT" -gt 0 ] && [ "$CURRENT_CLUSTER" != "$CLUSTER_NAME" ]; then
          echo "‚ùå Error: A different cluster '$CURRENT_CLUSTER' is currently running"
          echo "   Expected cluster: $CLUSTER_NAME"
          echo "   Please destroy the existing cluster or set TALOS_CLUSTER_NAME=$CURRENT_CLUSTER"
          exit 1
      fi
      
      # Check if expected cluster exists but is not accessible
      if [ -n "$CURRENT_CLUSTER" ] && [ "$CURRENT_CLUSTER" = "$CLUSTER_NAME" ] && [ "$NODE_COUNT" -gt 0 ]; then
          if ! kubectl cluster-info &> /dev/null || ! kubectl get nodes &> /dev/null; then
              echo "‚ùå Error: Cluster '$CLUSTER_NAME' exists but is not accessible via kubectl"
              echo "   Please check your cluster status and fix any issues"
              exit 1
          fi
          
          # Cluster exists and is accessible - verify configuration
          echo "‚úì Cluster '$CLUSTER_NAME' found and accessible"
          
          # Verify namespace exists
          if ! kubectl get namespace "$NAMESPACE" &> /dev/null; then
              echo "‚ö†Ô∏è  Namespace '$NAMESPACE' missing, will create"
          else
              echo "‚úì Namespace '$NAMESPACE' exists"
          fi
          
          # Verify Argo Workflows is installed
          if ! kubectl get crd workflows.argoproj.io &> /dev/null; then
              echo "‚ö†Ô∏è  Argo Workflows not installed, will install"
          else
              echo "‚úì Argo Workflows CRD exists"
              
              # If everything is configured, we are done
              if kubectl get namespace "$NAMESPACE" &> /dev/null; then
                  echo ""
                  echo "‚úÖ Cluster is already configured and ready!"
                  echo ""
                  
                  # Ensure service account and RBAC exist (idempotent)
                  echo "üì¶ Verifying service account and RBAC..."
                  kubectl create serviceaccount argo-odm -n "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f - &> /dev/null
                  kubectl create clusterrolebinding argo-odm-admin \
                      --clusterrole=admin \
                      --serviceaccount="$NAMESPACE:argo-odm" \
                      --dry-run=client -o yaml | kubectl apply -f - &> /dev/null
                  echo "‚úì Service account and RBAC verified"
                  echo ""
                  exit 0
              fi
          fi
      fi
  fi
  
  echo "üì¶ Creating Talos cluster $CLUSTER_NAME..."
  
  talosctl cluster create \
      --name "$CLUSTER_NAME" \
      --workers 1 \
      --memory "${CONTROL_PLANE_MEMORY}" \
      --memory-workers "${WORKER_MEMORY}" \
      --cpus 1 \
      --cpus-workers 2 \
      --wait
  
  echo ""
  echo "‚úì Talos cluster created successfully!"
  echo ""
  
  # Wait for cluster to be ready
  echo "‚è≥ Waiting for cluster to be ready..."
  kubectl wait --for=condition=Ready nodes --all --timeout=5m || {
      echo "‚ö†Ô∏è  Warning: Some nodes may not be ready yet"
  }
  
  # Get kubeconfig context name
  CONTEXT=$(kubectl config current-context)
  echo "‚úì Cluster is ready!"
  echo "   Kubeconfig context: $CONTEXT"
  echo ""
  
  # Install Argo Workflows if not already installed
  if ! kubectl get namespace "$NAMESPACE" &> /dev/null; then
      echo "üì¶ Creating namespace: $NAMESPACE"
      kubectl create namespace "$NAMESPACE"
  fi
  
  if ! kubectl get crd workflows.argoproj.io &> /dev/null; then
      echo "üì¶ Installing Argo Workflows $ARGO_VERSION..."
      kubectl apply -n "$NAMESPACE" -f "https://github.com/argoproj/argo-workflows/releases/download/${ARGO_VERSION}/install.yaml"
      
      # Wait for Argo Workflows to be ready
      echo "‚è≥ Waiting for Argo Workflows to be ready..."
      kubectl wait --for=condition=ready pod -l app=workflow-controller -n "$NAMESPACE" --timeout=5m || true
      kubectl wait --for=condition=ready pod -l app=argo-server -n "$NAMESPACE" --timeout=5m || true
  else
      echo "‚úì Argo Workflows already installed"
  fi
  
  # Create service account for workflows
  echo "üì¶ Setting up service account for workflows..."
  kubectl create serviceaccount argo-odm -n "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
  
  # Bind admin role to service account for workflow execution
  echo "üì¶ Setting up RBAC for workflows..."
  kubectl create clusterrolebinding argo-odm-admin \
      --clusterrole=admin \
      --serviceaccount="$NAMESPACE:argo-odm" \
      --dry-run=client -o yaml | kubectl apply -f -
  
  echo ""
  echo "‚úÖ Talos cluster setup complete!"
  echo ""
  echo "Next steps:"
  echo "  1. Start compose services: just start"
  echo "  2. Check cluster status: kubectl get nodes"
  echo "  3. Check Argo Workflows: kubectl get pods -n $NAMESPACE"
  echo ""
  echo "To destroy the cluster later:"
  echo "  just test cluster-destroy"

# Destroy the Talos test cluster
cluster-destroy:
  #!/usr/bin/env bash
  set -e
  
  CLUSTER_NAME="${TALOS_CLUSTER_NAME:-scaleodm-test}"
  
  echo "üóëÔ∏è  Destroying Talos cluster: $CLUSTER_NAME"
  talosctl cluster destroy --name "$CLUSTER_NAME"
  echo "‚úì Cluster destroyed"

# Run all tests (requires Talos cluster and compose services)
# Will start DB and S3 if not already running
# Automatically initializes cluster if not available
all:
  #!/usr/bin/env bash
  set -e

  just test cluster-available

  echo "Running tests..."
  docker compose -f compose.yaml -f compose.test.yaml run --rm api

# Run unit tests only (no external dependencies)
unit:
  go test -v -short ./app/api/helpers_test.go ./app/api/helpers.go ./app/workflows/workflow_test.go

# Run integration tests only (requires DB)
integration:
  #!/usr/bin/env bash
  set -e
  echo "Running integration tests..."
  docker compose -f compose.yaml -f compose.test.yaml run --rm api go test -v -short ./app/meta/... ./app/db/... ./app/api/...

# Run E2E tests only (requires DB, S3, and K8s)
e2e:
  #!/usr/bin/env bash
  set -e
  just test cluster-available
  echo "Running E2E tests..."
  docker compose -f compose.yaml -f compose.test.yaml run --rm api go test -v -tags=e2e .
